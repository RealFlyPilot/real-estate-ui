## To Do

[] - Define Custom Component APIs
[] - Mitigate the presence of both xStyledComponent and StyledComponents

## Issues

**
Currently experiencing issues with properly defining and exporting our own custom components when the base WelcomeUI components that they wrap internally have properties that reference sub components. As an example,
a <BaseDropdownComponent> that itself exposes <BaseDropdownComponent.Trigger> as well as <BaseDropdownComponent.Item>. How do we properly define the API around our own components when the underlying dependencies are composed like this?
**
We are presently handling this in two ways

Either we simply import the base component and set our custom component equal to it.

```
import { Alert as BaseAlert } from '@welcome-ui/alert'

const Alert = BaseAlert

export { Alert }

```

or we wrap the internal component in our custom component and then define properties on our custom component that mirror the underlying WelcomeUI component's API.

```
import { Breadcrumb as BaseBreadCrumb } from '@welcome-ui/breadcrumb'

export interface BreadcrumbProps extends BaseComponentStylePropType {
  separator?: any
}

const Breadcrumb: React.SFC<BreadcrumbProps> = (props) => {
  return <BaseBreadCrumb {...props} />
}

// @ts-ignore
Breadcrumb.Item = BaseBreadCrumb.Item

export { Breadcrumb }

```

These both seem far from ideal but the second way seems particularly worse. Since the underlying component already has sub components mapped to its properties of the same name, to define those same properties on the wrapper component
seems redundant and likely to cause bloat. **Would like a second pair of eyes on this**

[] - DropdownMenu & useDropdownMenuState (helper function for managing local state)
[] - Alert
[] - Breadcrumb
[] = Card
